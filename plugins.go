package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
)

// Global plugin registry - simple map of functions
var plugins = map[string]PluginFunc{
	"iterm2":       iterm2Plugin,
	"cursor":       cursorPlugin,
	"claude-code":  claudeCodePlugin,
	"neovim":       neovimPlugin,
	"macos-system": macosSystemPlugin,
}

// iterm2Plugin switches iTerm2 color presets via AppleScript
func iterm2Plugin(cfg map[string]interface{}, isLight bool) error {
	presetKey := "dark_preset"
	if isLight {
		presetKey = "light_preset"
	}

	preset, ok := cfg[presetKey].(string)
	if !ok {
		return fmt.Errorf("missing %s configuration", presetKey)
	}

	script := fmt.Sprintf(`
tell application "iTerm"
	repeat with aWindow in windows
		repeat with aTab in tabs of aWindow
			repeat with aSession in sessions of aTab
				tell aSession
					set color preset to "%s"
				end tell
			end repeat
		end repeat
	end repeat
end tell
`, preset)

	cmd := exec.Command("osascript", "-e", script)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("osascript failed: %w: %s", err, output)
	}

	return nil
}

// cursorPlugin updates Cursor settings.json
func cursorPlugin(cfg map[string]interface{}, isLight bool) error {
	themeKey := "dark_theme"
	defaultTheme := "Default Dark+"
	if isLight {
		themeKey = "light_theme"
		defaultTheme = "Default Light+"
	}

	theme, ok := cfg[themeKey].(string)
	if !ok {
		theme = defaultTheme
	}

	settingsPath := filepath.Join(
		os.Getenv("HOME"),
		"Library/Application Support/Cursor/User/settings.json",
	)

	return updateJSONTheme(settingsPath, "workbench.colorTheme", theme)
}

// claudeCodePlugin updates Claude Code settings.json
func claudeCodePlugin(cfg map[string]interface{}, isLight bool) error {
	theme := "dark"
	if isLight {
		theme = "light"
	}

	settingsPath := filepath.Join(os.Getenv("HOME"), ".claude/settings.json")
	return updateJSONTheme(settingsPath, "theme", theme)
}

// neovimPlugin writes theme configuration file
func neovimPlugin(cfg map[string]interface{}, isLight bool) error {
	mode := "dark"
	colorschemeKey := "dark_colorscheme"
	if isLight {
		mode = "light"
		colorschemeKey = "light_colorscheme"
	}

	themePath := filepath.Join(os.Getenv("HOME"), ".config/nvim/theme.lua")

	var content string
	if colorscheme, ok := cfg[colorschemeKey].(string); ok {
		content = fmt.Sprintf(`-- Auto-generated by day-night-cycle
-- Set colorscheme to %s mode
vim.o.background = "%s"
vim.cmd.colorscheme("%s")
`, mode, mode, colorscheme)
	} else {
		content = fmt.Sprintf(`-- Auto-generated by day-night-cycle
-- Set background to %s mode
vim.o.background = "%s"
`, mode, mode)
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(themePath), 0755); err != nil {
		return err
	}

	if err := os.WriteFile(themePath, []byte(content), 0644); err != nil {
		return err
	}

	// Best effort: try to notify running Neovim instances
	// Don't fail if this doesn't work
	notifyNeovim(themePath)

	return nil
}

// notifyNeovim attempts to notify running Neovim instances (best effort)
func notifyNeovim(themePath string) {
	// Try nvr (neovim-remote) first
	cmd := exec.Command("nvr", "--remote-expr", fmt.Sprintf("luafile %s", themePath))
	_ = cmd.Run() // Ignore errors

	// Try nvim --remote-expr as fallback
	if cmd.ProcessState != nil && !cmd.ProcessState.Success() {
		cmd = exec.Command("nvim", "--remote-expr", fmt.Sprintf("luafile %s", themePath))
		_ = cmd.Run() // Ignore errors
	}
}

// macosSystemPlugin sets system-wide appearance
func macosSystemPlugin(cfg map[string]interface{}, isLight bool) error {
	darkMode := "true"
	if isLight {
		darkMode = "false"
	}

	script := fmt.Sprintf(`
tell application "System Events"
	tell appearance preferences
		set dark mode to %s
	end tell
end tell
`, darkMode)

	cmd := exec.Command("osascript", "-e", script)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("osascript failed: %w: %s", err, output)
	}

	// Optional wallpaper support
	wallpaperKey := "dark_wallpaper"
	if isLight {
		wallpaperKey = "light_wallpaper"
	}

	if wallpaper, ok := cfg[wallpaperKey].(string); ok {
		fullPath := expandPath(wallpaper)

		// Check if file exists
		if _, err := os.Stat(fullPath); err != nil {
			// Don't fail on wallpaper errors, just warn
			fmt.Printf("    Warning: wallpaper file not found: %s\n", fullPath)
			return nil
		}

		wallpaperScript := fmt.Sprintf(`
tell application "Finder"
	set desktop picture to POSIX file "%s"
end tell
`, fullPath)

		cmd := exec.Command("osascript", "-e", wallpaperScript)
		_ = cmd.Run() // Best effort, don't fail if wallpaper fails
	}

	return nil
}

// Helper functions

// updateJSONTheme updates a JSON file with a new theme value
func updateJSONTheme(path, key, value string) error {
	// Read existing file
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read %s: %w", path, err)
	}

	var settings map[string]interface{}
	if err := json.Unmarshal(data, &settings); err != nil {
		return fmt.Errorf("failed to parse %s: %w", path, err)
	}

	// Check if already set (optimization)
	if current, ok := settings[key].(string); ok && current == value {
		return nil
	}

	// Update the key
	settings[key] = value

	// Write back with formatting
	output, err := json.MarshalIndent(settings, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal JSON: %w", err)
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	if err := os.WriteFile(path, output, 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", path, err)
	}

	return nil
}

// expandPath handles ~ expansion in file paths
func expandPath(path string) string {
	if len(path) > 0 && path[0] == '~' {
		home, err := os.UserHomeDir()
		if err != nil {
			return path
		}
		return filepath.Join(home, path[1:])
	}
	return path
}
